/* * GameEngine - A cross platform game engine made using OpenGL and c++
 * Copyright (C) 2016-2020 Matan Keren <xmakerenx@gmail.com>
 *
 * This file is part of GameEngine.
 *
 * GameEngine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GameEngine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GameEngine.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef  _FONT_H
#define  _FONT_H

#include <iostream>
#include <utility>
#include <unordered_map>
#include <fstream>
#include <GL/glew.h>
#include <glm/glm.hpp>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <string>
#include "RenderTypes.h"
#include "Shader.h"
#include "Sprite.h"

struct FontInfo
{
    FontInfo()
    {
        fontName = "";
        fontSize = 0;
    }

    FontInfo(const FontInfo& toCopy)
    {
        fontName = toCopy.fontName;
        fontSize = toCopy.fontSize;
    }

    FontInfo(std::string fontName, int fontSize)
    {
        this->fontName = fontName;
        this->fontSize = fontSize;
    }

    std::string fontName;
    int fontSize;
};

// Holds all state information relevant to a character glyph as loaded using FreeType
struct CharGlyph {
    GLuint     TextureID;
    glm::ivec2 Size;
    glm::ivec2 Bearing;     // Offset from baseline to left/top of glyph
    long       Advance;     // Horizontal offset to advance to next glyph
};

struct CharGlyphAtlas
{
    Rect textureRect;
    glm::ivec2 Size;
    glm::ivec2 Bearing;     // Offset from baseline to left/top of glyph
    long       Advance;     // Horizontal offset to advance to next glyph
};

class mkFont
{
public:
    enum class TextFormat{Left, Center, HorizCenter, VerticalCenter, Right, RightVerticalCenter};

    mkFont();
    mkFont(std::string fontName, bool isPath = false);
    mkFont(const mkFont&  toCopy);
    mkFont(mkFont&& toMove);
    ~mkFont();

    int init(int m_fontSize, int hDpi, int vDpi);

    void renderText(Shader *shader, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color);

    Point calcTextRect(std::string text);
    Point clipTextToRect(const Rect& rc, std::string& textInRect, int maxTextHeight);

    void renderTextAtlas(Sprite &sprite, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec4 color);
    void renderToRect(Sprite& sprite, std::string text, Rect rc, glm::vec4 color, TextFormat format = TextFormat::Left, bool clipText = true);
    GLuint renderFontAtlas(Sprite& sprite, const Rect &rc);

    static std::string getFontPath(std::string fontName);
    static std::string getFontNameFromPath(std::string path);

    GLuint getFontSize();

    static void printallFonts();

private:
    void cacheGlyth(FT_Library ft, FT_Face face);
    void createFontAtlas(FT_Library ft, FT_Face face);

    std::string fontPath;
    std::unordered_map<GLchar, CharGlyph> charGlyphs;
    std::unordered_map<GLchar, CharGlyphAtlas> charGlyphsAtlas;
    GLuint VAO;
    GLuint VBO;
    VertexIndex indices[6];

    GLuint m_maxRows;
    GLuint m_avgWidth;

    GLuint m_textureAtlas;
    GLuint m_textureAtlasWidth;
    GLuint m_textureAtlasHeight;
    GLuint m_fontSize;

    // values that are generated by calcTextRect and are being cached as to not recalculate them
    std::string m_cachedText;
    Point m_cachedTextSize;
    int m_cachedMaxBearing;
};

#endif  //_FONT_H
